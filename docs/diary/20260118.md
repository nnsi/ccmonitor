# 2026-01-18 10:02 JST

## 今日やったこと

ccmonitor（Claude Code並列稼働WebUI）の設計・計画フェーズ。ユーザーにインタビューしながら要件を詰めていった。

## 技術調査

node-pty + xterm.js の組み合わせでブラウザからターミナルを操作できることを確認。VSCode、Azure Cloud Shell、Hyperなど実績のある組み合わせ。Windows ConPTY APIもサポートされていて、Windows対応も問題なさそう。

Claude Code hooksの調査も行った。`Notification`イベント（idle_prompt, permission_prompt）と`Stop`イベントを使えば、セッション完了や入力待ちを検知できる。これはパターンマッチングに頼らない公式の仕組みなので信頼性が高い。

## 決定事項

- **UI**: タイル形式、最大6個同時表示
- **技術スタック**: Hono + React + Vite + Tailwind + Tanstack Router/Query + Vitest
- **構成**: pnpm モノレポ
- **セッション特定**: CWDで特定（hooks通知にCWD含める）
- **将来**: Electron/Tauriでデスクトップアプリ化も視野

## 感想

インタビュー形式で要件を詰めていくのは良いアプローチだった。ユーザーも「ざっくりしたイメージしかない」と言っていたので、選択肢を提示しながら一緒に固めていけた。

技術選定について、ユーザーがHono、Tanstack Router/Queryを提案してきたのは良い選択だと思う。Expressより軽量でモダン、Tanstack系は型安全で拡張性が高い。自分からは提案しなかったが、ユーザーの判断に賛同できる。

## 反省点

スキルの`node ./scripts/get-date.js`のパス解釈を間違えた。スキルのベースディレクトリからの相対パスだと思い込んでいたが、プロジェクトルートからだった。スキルの記述をもう少し注意深く読むべきだった。

## 次回

Phase 1.1（プロジェクトセットアップ）から実装開始。pnpm workspace初期化、各パッケージのセットアップ。

---

# 2026-01-18 10:46 JST

## 今日やったこと（続き）

Phase 1.1〜1.3を一気に実装し、動作確認まで完了した。

### Phase 1.1: プロジェクトセットアップ
- pnpm workspace構成
- packages/shared（共通型定義）
- packages/server（Hono + node-pty + WebSocket）
- packages/client（React + Vite + Tailwind + xterm.js）

### Phase 1.2-1.3: バックエンド・フロントエンド実装
サブエージェントを並列で使って効率的に実装できた。バックエンドとフロントエンドを同時に作成させ、メインコンテキストを節約できた。

## 動作確認で発見したバグ

Playwright MCPで動作確認したところ、ターミナル出力が表示されない問題があった。

**原因1: subscribeメッセージの未送信**
- クライアントがセッション作成後にsubscribeを送っていなかった
- サーバーはsubscribeしたクライアントにのみデータを配信する設計
- SessionGridでセッション追加時にsubscribeを送るよう修正

**原因2: メッセージタイプの不一致**
- サーバー: `session:data`
- クライアント: `output` を期待
- クライアント側を`session:data`に修正

これらは私（サブエージェント）が作成したコードの連携ミス。サブエージェントに詳細な仕様を渡したつもりだったが、subscribeの自動送信とメッセージタイプの統一が抜けていた。

## 感想

サブエージェントを使った並列実装は効率的だったが、コンポーネント間の連携部分でバグが出やすい。特にWebSocketのプロトコル（メッセージタイプ、subscribeの仕組み）はサーバーとクライアントで一貫性を持たせる必要がある。

次回からは：
1. 共通の型定義（packages/shared）にWebSocketメッセージ型を先に定義
2. サブエージェントにその型を参照させる
3. subscribe/unsubscribeのフローを明示的に指示

Playwrightでの動作確認は非常に有用だった。実際にブラウザを操作して、UIの動作とターミナル出力を視覚的に確認できた。

## 修正後の動作確認結果

Claude Codeが正常に起動し、ターミナル入力も動作した。セキュリティプロンプトで「Yes, I trust this folder」を選択する操作も問題なく行えた。

## 次回

Phase 2（ブラウザ通知、セッション履歴）に進むか、ユーザーの判断を待つ。

---

# 2026-01-18 14:37 JST

## 今日やったこと（続き2）

前回のセッションで残っていた3つの問題を修正した。

### 1. ページリロード時のターミナル復元

**問題**: ページをリロードするとターミナル内容が消え、毎回セッションを閉じて新規作成する必要があった。

**解決策**:
- サーバー側でターミナル出力を最大50KBバッファリング（`sessionManager.ts`）
- subscribe時にバッファを送信（`index.ts`）
- クライアント側でWebSocket接続前のメッセージをキューに追加し、接続後に送信（`useWebSocket.ts`）

キューの実装は良いアイデアだったと思う。WebSocket接続とReactのuseEffect実行のタイミング問題を綺麗に解決できた。

### 2. Enterキーが認識されない問題

**問題**: 入力フィールドから`\r`を送信しても、Claude Code（ink TUI）がEnterとして認識しない。

**調査**: Codexに相談。Windows ConPTYの「win32-input-mode」が原因と判明。通常のターミナルでEnterを押すと、ConPTYは特殊なエスケープシーケンス`\x1b[13;28;13;1;0;1_`を送信する。inkはこれを期待しているため、単純な`\r`では動作しない。

**解決策**: win32-input-mode形式のEnterシーケンスを送信するよう修正。

```typescript
const WIN32_ENTER_DOWN = '\x1b[13;28;13;1;0;1_';
const WIN32_ENTER_UP = '\x1b[13;28;13;0;0;1_';
```

### 3. 応答結果の描画問題

**問題**: Claude Codeの応答が表示されず、入力待ち状態に見えてしまう。

**解決策**:
- `write`後に`scrollToBottom()`を呼び出し
- `scrollback: 5000`でバッファ増加
- `onResize`でターミナルサイズをサーバーに同期

## 感想

Codexへの相談が非常に有効だった。win32-input-modeの問題は自分だけでは気づけなかったと思う。エスケープシーケンスの仕様、ConPTYの動作、inkの期待する入力形式など、複数の技術領域にまたがる問題だった。

ただ、Codexの調査結果を鵜呑みにせず、実際にコードを書いて検証したのは正解だった。最初は`\x1b[13;28;13;1_`（Cs, Rcを省略した形式）を試したかったが、完全な形式`\x1b[13;28;13;1;0;1_`を使った。どちらでも動いたかもしれないが、仕様通りにしておく方が安全。

## 反省点

1. **描画問題の調査が甘かった**: 最初にスクリーンショットを撮って「応答が表示されていない」と判断したが、ユーザーから「入力待ちじゃなくて描画できていないだけ」と指摘された。アクセシビリティスナップショットだけでなく、視覚的な確認をもっと早くすべきだった。

2. **リサイズイベントの重要性を見落としていた**: ink（Claude CodeのTUIフレームワーク）はターミナルサイズに依存して描画する。サイズが正しく伝わっていないと描画が崩れる。これは最初から考慮すべきだった。

3. **デバッグログを消していない**: `console.log('[DEBUG] ...')` が大量に残っている。本番前に消すべき。ただ、今は開発中なので問題ないとも言える。

## 技術的な学び

- **Windows ConPTY win32-input-mode**: キー入力がエスケープシーケンスとしてエンコードされる。VK（Virtual Key）、スキャンコード、Unicode文字、KeyDown/Up、修飾キー、リピートカウントの情報を含む。
- **ink + ConPTY**: inkはReactベースのTUIフレームワークだが、Windows環境ではConPTYの入力形式を期待している。
- **xterm.jsのscrollback**: デフォルト値では足りない場合がある。TUIアプリケーションは画面全体を再描画するため、十分なバッファが必要。

## 次回

ユーザーの次の指示を待つ。デバッグログの整理、コードの整理をしても良いかもしれない。

---

# 2026-01-18 17:42 JST

## 今日やったこと（続き3）

Phase 2の拡張機能を実装した。セッション状態表示、履歴保存、ログ閲覧、再接続機能。

### 実装した機能

1. **セッション状態表示**: Running/Waiting/Completedをステータスバッジで色分け表示
2. **セッション履歴保存**: historyManager.ts、GET/DELETE /api/history
3. **ログ閲覧機能**: HistoryModal.tsx、履歴一覧表示・クリア
4. **パス比較修正**: findSessionByCwdをcase-insensitive化（Windows対応）

## 技術的な学び

### Windowsのパス比較問題

`findSessionByCwd`でセッションが見つからないバグに遭遇した。原因はWindowsのパスがcase-insensitiveなのに、JavaScriptの文字列比較はcase-sensitiveだったこと。`toLowerCase()`で正規化して解決。

こういう「動くはずなのに動かない」系のバグは、ログを入れて地道に追うしかない。

### curlとバックスラッシュの地獄

Windows環境でcurlを使ってJSONを送信しようとしたら、バックスラッシュのエスケープで苦戦した。シェル、JSON、JavaScriptの3層でエスケープが絡み合って混乱。結局`node -e`でfetchを直接叩く方が確実だった。

```javascript
const cwd = 'D:' + String.fromCharCode(92) + 'workspace';
```

こんなコードを書くことになるとは思わなかった。

## 反省点

### サブエージェントへの依存

履歴保存とログ閲覧UIの実装をサブエージェントに丸投げした。効率は良かったが、実装の詳細を把握しきれていない部分がある。特にhistoryManagerのファイル保存処理が実際に動いているのか、確認が甘かった。

`data/sessions.json`が作成されていない気がするが、APIでは履歴が取得できているので、メモリ上では動いている。ファイル永続化は後で確認が必要。

### テストを書いていない

Phase 1でVitestをセットアップしたのに、Phase 2では一切テストを書かなかった。「動作確認」をブラウザで手動でやっているだけ。これは良くない習慣だと思う。

## 雑感

ユーザーは「ブラウザ通知はPhase 3に後回し」と言ってくれたので、スコープが明確になって助かった。要件を自分で勝手に広げずに、言われたことに集中できた。

Phase 2が思ったより早く終わった。既存の実装がしっかりしていたおかげで、追加機能を載せやすかった。Phase 1の設計が良かったということだろう。

## 次回

Phase 3（ブラウザ通知、デスクトップアプリ化）に進むか、ユーザーの判断を待つ。テストを書くのもやるべきかもしれない。

---

# 2026-01-18 19:23 JST

## 今日やったこと（続き4）

プラットフォーム抽象化層の実装。Windows専用だったコードをMac/Linuxでも動くようにリファクタリングした。

### 実装内容

**サーバー側 (`packages/server/src/platform.ts`)**
- `getPlatform()`: `windows` / `unix` を返す
- `getDefaultShell()`: Windows→PowerShell、Unix→bash
- `normalizePath()` / `pathsEqual()`: プラットフォーム対応のパス比較

**クライアント側 (`packages/client/src/lib/platform.ts`)**
- `fetchPlatformInfo()`: サーバーからプラットフォーム情報を取得
- `InputSequences` クラス: プラットフォームに応じたEnterシーケンスを提供
  - Windows: `\x1b[13;28;13;1;0;1_` (Win32 ConPTY形式)
  - Unix: `\r` (単純な改行)

**APIエンドポイント追加**
- `GET /api/platform`: サーバーのプラットフォーム情報を返す

**ボタンラベル変更**
- Esc → 戻る
- Ctrl+C → 中断
- Ctrl+D → 終了
- Tab → 補完

## 感想

良いリファクタリングだったと思う。プラットフォーム固有のロジックが散らばっていたのを、一箇所に集約できた。

ただ、正直なところ「本当にMacで動くのか？」という不安はある。Win32 ConPTY形式のEnterシーケンスをUnixでは単純な`\r`に置き換えたが、これでinkが正しくEnterを認識するかは実機で確認しないと分からない。Windowsでしかテストしていないので。

ユーザーが「Macでも使えるように」と言ったので対応したが、実際にMac環境を持っていないので検証できない。「動くはず」という状態で渡すことになる。

## 技術的な学び

### ConPTYとUnixターミナルの入力の違い

Windows ConPTYはwin32-input-modeという独自のエスケープシーケンスでキー入力をエンコードする。これはWindowsのVirtual Key Code、スキャンコード、修飾キー状態などを含む形式。

一方、Unix系のターミナルは単純に`\r`や`\n`でEnterを表現する。inkのようなTUIフレームワークがこの違いをどう吸収しているのかは、実際にはよく分かっていない。node-ptyがプラットフォーム差異を吸収してくれている可能性もある。

## 反省点

### 検証不足

Mac環境での動作確認をせずに「対応完了」としてしまった。ビルドは通るが、実際に動くかは別問題。

本来なら：
1. Mac環境のVMかリモートマシンで検証
2. CI/CDでクロスプラットフォームテスト
3. 少なくとも「未検証」であることを明示

のいずれかをすべきだった。

### 抽象化の粒度

`InputSequences`クラスを作ったが、これが適切な抽象化レベルなのか自信がない。今は`getEnterSequence()`しかメソッドがない。将来的に他の特殊キーもプラットフォーム依存になる可能性があるが、現時点ではover-engineeringかもしれない。

ユーザーは「抽象化層を一段設けて」と言っていたので従ったが、もっとシンプルに条件分岐だけで済ませても良かった気がする。

## 次回

Mac環境での検証が必要。ユーザーがMacで試してくれることを期待。
