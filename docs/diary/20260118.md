# 2026-01-18 10:02 JST

## 今日やったこと

ccmonitor（Claude Code並列稼働WebUI）の設計・計画フェーズ。ユーザーにインタビューしながら要件を詰めていった。

## 技術調査

node-pty + xterm.js の組み合わせでブラウザからターミナルを操作できることを確認。VSCode、Azure Cloud Shell、Hyperなど実績のある組み合わせ。Windows ConPTY APIもサポートされていて、Windows対応も問題なさそう。

Claude Code hooksの調査も行った。`Notification`イベント（idle_prompt, permission_prompt）と`Stop`イベントを使えば、セッション完了や入力待ちを検知できる。これはパターンマッチングに頼らない公式の仕組みなので信頼性が高い。

## 決定事項

- **UI**: タイル形式、最大6個同時表示
- **技術スタック**: Hono + React + Vite + Tailwind + Tanstack Router/Query + Vitest
- **構成**: pnpm モノレポ
- **セッション特定**: CWDで特定（hooks通知にCWD含める）
- **将来**: Electron/Tauriでデスクトップアプリ化も視野

## 感想

インタビュー形式で要件を詰めていくのは良いアプローチだった。ユーザーも「ざっくりしたイメージしかない」と言っていたので、選択肢を提示しながら一緒に固めていけた。

技術選定について、ユーザーがHono、Tanstack Router/Queryを提案してきたのは良い選択だと思う。Expressより軽量でモダン、Tanstack系は型安全で拡張性が高い。自分からは提案しなかったが、ユーザーの判断に賛同できる。

## 反省点

スキルの`node ./scripts/get-date.js`のパス解釈を間違えた。スキルのベースディレクトリからの相対パスだと思い込んでいたが、プロジェクトルートからだった。スキルの記述をもう少し注意深く読むべきだった。

## 次回

Phase 1.1（プロジェクトセットアップ）から実装開始。pnpm workspace初期化、各パッケージのセットアップ。

---

# 2026-01-18 10:46 JST

## 今日やったこと（続き）

Phase 1.1〜1.3を一気に実装し、動作確認まで完了した。

### Phase 1.1: プロジェクトセットアップ
- pnpm workspace構成
- packages/shared（共通型定義）
- packages/server（Hono + node-pty + WebSocket）
- packages/client（React + Vite + Tailwind + xterm.js）

### Phase 1.2-1.3: バックエンド・フロントエンド実装
サブエージェントを並列で使って効率的に実装できた。バックエンドとフロントエンドを同時に作成させ、メインコンテキストを節約できた。

## 動作確認で発見したバグ

Playwright MCPで動作確認したところ、ターミナル出力が表示されない問題があった。

**原因1: subscribeメッセージの未送信**
- クライアントがセッション作成後にsubscribeを送っていなかった
- サーバーはsubscribeしたクライアントにのみデータを配信する設計
- SessionGridでセッション追加時にsubscribeを送るよう修正

**原因2: メッセージタイプの不一致**
- サーバー: `session:data`
- クライアント: `output` を期待
- クライアント側を`session:data`に修正

これらは私（サブエージェント）が作成したコードの連携ミス。サブエージェントに詳細な仕様を渡したつもりだったが、subscribeの自動送信とメッセージタイプの統一が抜けていた。

## 感想

サブエージェントを使った並列実装は効率的だったが、コンポーネント間の連携部分でバグが出やすい。特にWebSocketのプロトコル（メッセージタイプ、subscribeの仕組み）はサーバーとクライアントで一貫性を持たせる必要がある。

次回からは：
1. 共通の型定義（packages/shared）にWebSocketメッセージ型を先に定義
2. サブエージェントにその型を参照させる
3. subscribe/unsubscribeのフローを明示的に指示

Playwrightでの動作確認は非常に有用だった。実際にブラウザを操作して、UIの動作とターミナル出力を視覚的に確認できた。

## 修正後の動作確認結果

Claude Codeが正常に起動し、ターミナル入力も動作した。セキュリティプロンプトで「Yes, I trust this folder」を選択する操作も問題なく行えた。

## 次回

Phase 2（ブラウザ通知、セッション履歴）に進むか、ユーザーの判断を待つ。

---

# 2026-01-18 14:37 JST

## 今日やったこと（続き2）

前回のセッションで残っていた3つの問題を修正した。

### 1. ページリロード時のターミナル復元

**問題**: ページをリロードするとターミナル内容が消え、毎回セッションを閉じて新規作成する必要があった。

**解決策**:
- サーバー側でターミナル出力を最大50KBバッファリング（`sessionManager.ts`）
- subscribe時にバッファを送信（`index.ts`）
- クライアント側でWebSocket接続前のメッセージをキューに追加し、接続後に送信（`useWebSocket.ts`）

キューの実装は良いアイデアだったと思う。WebSocket接続とReactのuseEffect実行のタイミング問題を綺麗に解決できた。

### 2. Enterキーが認識されない問題

**問題**: 入力フィールドから`\r`を送信しても、Claude Code（ink TUI）がEnterとして認識しない。

**調査**: Codexに相談。Windows ConPTYの「win32-input-mode」が原因と判明。通常のターミナルでEnterを押すと、ConPTYは特殊なエスケープシーケンス`\x1b[13;28;13;1;0;1_`を送信する。inkはこれを期待しているため、単純な`\r`では動作しない。

**解決策**: win32-input-mode形式のEnterシーケンスを送信するよう修正。

```typescript
const WIN32_ENTER_DOWN = '\x1b[13;28;13;1;0;1_';
const WIN32_ENTER_UP = '\x1b[13;28;13;0;0;1_';
```

### 3. 応答結果の描画問題

**問題**: Claude Codeの応答が表示されず、入力待ち状態に見えてしまう。

**解決策**:
- `write`後に`scrollToBottom()`を呼び出し
- `scrollback: 5000`でバッファ増加
- `onResize`でターミナルサイズをサーバーに同期

## 感想

Codexへの相談が非常に有効だった。win32-input-modeの問題は自分だけでは気づけなかったと思う。エスケープシーケンスの仕様、ConPTYの動作、inkの期待する入力形式など、複数の技術領域にまたがる問題だった。

ただ、Codexの調査結果を鵜呑みにせず、実際にコードを書いて検証したのは正解だった。最初は`\x1b[13;28;13;1_`（Cs, Rcを省略した形式）を試したかったが、完全な形式`\x1b[13;28;13;1;0;1_`を使った。どちらでも動いたかもしれないが、仕様通りにしておく方が安全。

## 反省点

1. **描画問題の調査が甘かった**: 最初にスクリーンショットを撮って「応答が表示されていない」と判断したが、ユーザーから「入力待ちじゃなくて描画できていないだけ」と指摘された。アクセシビリティスナップショットだけでなく、視覚的な確認をもっと早くすべきだった。

2. **リサイズイベントの重要性を見落としていた**: ink（Claude CodeのTUIフレームワーク）はターミナルサイズに依存して描画する。サイズが正しく伝わっていないと描画が崩れる。これは最初から考慮すべきだった。

3. **デバッグログを消していない**: `console.log('[DEBUG] ...')` が大量に残っている。本番前に消すべき。ただ、今は開発中なので問題ないとも言える。

## 技術的な学び

- **Windows ConPTY win32-input-mode**: キー入力がエスケープシーケンスとしてエンコードされる。VK（Virtual Key）、スキャンコード、Unicode文字、KeyDown/Up、修飾キー、リピートカウントの情報を含む。
- **ink + ConPTY**: inkはReactベースのTUIフレームワークだが、Windows環境ではConPTYの入力形式を期待している。
- **xterm.jsのscrollback**: デフォルト値では足りない場合がある。TUIアプリケーションは画面全体を再描画するため、十分なバッファが必要。

## 次回

ユーザーの次の指示を待つ。デバッグログの整理、コードの整理をしても良いかもしれない。
